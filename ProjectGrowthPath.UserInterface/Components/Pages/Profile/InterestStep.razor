@using ProjectGrowthPath.Application.Service
@using System.ComponentModel.DataAnnotations
@using System.Net
@using Humanizer
@using ProjectGrowthPath.Application.Interfaces
@using ProjectGrowthPath.Application.State
@using ProjectGrowthPath.Domain.Entities
@using MudBlazor


@inject FirstTimeSetupService SetupService
@inject SetupStateStore StateStorage
@inject ICompetenceRepository CompetenceRepository
@implements IDisposable

<MudThemeProvider />
<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />


@if (IsLoading)
{
    <MudProgressCircular Indeterminate="true" />
}
else
{
    <h3>Kies 3 vaardigheden waarin je interesse hebt.</h3>
    <p>Geen zorgen, later kan je meer kiezen!</p>
    <MudGrid>
        <MudItem xs="12">
            <MudAutocomplete T="Competence"
            Label="Eerste keuze"
            Value="comp1"
            ValueChanged="@(c => SelectCompetenceAsync(1, c))"
            SearchFunc="(val, token) => SearchForComp(val, token, new[] { comp2, comp3 })"
            ToStringFunc="@(c=> c==null?null : $"{c.Name} ({c.Description})")"
            Clearable=true/>
        </MudItem>
        <MudItem xs="12" >
            <MudAutocomplete T="Competence"
            Label="Tweede keuze"
            Value="comp2"
            ValueChanged="@(c => SelectCompetenceAsync(2, c))"
            SearchFunc="(val, token) => SearchForComp(val, token, new[] { comp1, comp3 })"
            ToStringFunc="@(c=> c==null?null : $"{c.Name} ({c.Description})")" 
            Clearable=true/>
        </MudItem>
        <MudItem xs="12">
            <MudAutocomplete T="Competence"
            Label="Derde keuze"
            Value="comp3"
            ValueChanged="@(c => SelectCompetenceAsync(3, c))"
            SearchFunc="(val, token) => SearchForComp(val, token, new[] { comp1, comp2 })"
            ToStringFunc="@(c=> c==null?null : $"{c.Name} ({c.Description})")" 
            Clearable=true/>
        </MudItem>
        <MudItem xs="12" md="12">
            <MudText Class="mb-n3" Typo="Typo.body2">
                Selectie van interesses: 
                <MudChip T="string">@(comp1?.Name ?? "Niet geselecteerd")</MudChip>
                <MudChip T="string">@(comp2?.Name ?? "Niet geselecteerd")</MudChip>
                <MudChip T="string">@(comp3?.Name ?? "Niet geselecteerd")</MudChip>
            </MudText>
        </MudItem>
    </MudGrid>

    <div class="mt-4">
        <button class="btn btn-outline-secondary me-2" @onclick="() => OnBack.InvokeAsync()">Terug</button>
        <button class="btn btn-success" @onclick="() => OnNext.InvokeAsync()" disabled="@(!CanProceed)">Volgende</button>
    </div>
}


@code {
    [Parameter] public EventCallback OnNext { get; set; }
    [Parameter] public EventCallback OnBack { get; set; }
    private Competence comp1, comp2, comp3;
    private List<Competence> AllCompetences { get; set; } = new();


    private bool _disposed;
    private bool _isFirstRender = true;
    private bool IsLoading = true;

    private bool CanProceed => comp1 != null && comp2 != null && comp3 != null
                               && comp1 != comp2 && comp1 != comp3 && comp2 != comp3;

    public void Dispose()
    {
        _disposed = true;
    }


    //
    protected override async Task OnInitializedAsync()
    {
        var competences = await CompetenceRepository.GetAllAsync();

        if (_disposed) return;

        AllCompetences = competences;

        IsLoading = false;
        await InvokeAsync(StateHasChanged);
    }

    // Eerste render al opgeslagen competenties ophalen
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _isFirstRender)
        {
            await StateStorage.LoadAsync();

            var selected = StateStorage.CurrentState.SelectedInterests;
            if (selected != null)
            {
                selected.TryGetValue(1, out comp1);
                selected.TryGetValue(2, out comp2);
                selected.TryGetValue(3, out comp3);
            }

            _isFirstRender = false;
            await InvokeAsync(StateHasChanged);
        }
    }


    // Complete lijst van competenties ophalen. 
    private IEnumerable<Competence> GetAvailableCompetences(params Competence[] exclude)
    {
        return AllCompetences
            .Where(c => !exclude.Contains(c))
            .ToList();
    }

    // Om ervoor te zorgen dat dezelfde competencies niet worden gedisplayed in de resultaten
    private Task<IEnumerable<Competence>> SearchForComp(string value, CancellationToken token, Competence[] exclude)
    {
        return Task.FromResult(FilterCompetences(value, GetAvailableCompetences(exclude)));
    }

    private IEnumerable<Competence> FilterCompetences(string value, IEnumerable<Competence> source)
    {
        if (string.IsNullOrWhiteSpace(value))
            return source;

        return source
            .Where(c => c.Name.Contains(value, StringComparison.InvariantCultureIgnoreCase))
            .ToList();
    }

    private async Task SelectCompetenceAsync(int number, Competence competence)
    {
        string typeComp = "interests";

        switch (number)
        {
            case 1:
                comp1 = competence;
                break;
            case 2:
                comp2 = competence;
                break;
            case 3:
                comp3 = competence;
                break;
        }

        await SetupService.UpdateCompetenceDictionary(number, competence, typeComp);
    }

}
