@using ProjectGrowthPath.Application.Service
@using ProjectGrowthPath.Application.Interfaces
@using ProjectGrowthPath.Application.State
@using ProjectGrowthPath.Domain.Entities
@using MudBlazor
@inject FirstTimeSetupService SetupService
@inject SetupStateStore StateStorage
@inject ICompetenceRepository CompetenceRepository
@implements IDisposable

<MudThemeProvider />
<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

@if (IsLoading)
{
    <MudProgressCircular Indeterminate="true" />
}
else
{
    <h3>@Title</h3>
    <p>@Subtitle</p>
    <MudGrid>
        @foreach (var number in new[] { 1, 2, 3 })
        {
            <MudItem xs="12">
                <MudAutocomplete T="Competence"
                                 Label="@($"Keuze {number}")"
                                 Value="@GetComp(number)"
                                 ValueChanged="@(c => SelectCompetenceAsync(number, c))"
                                 SearchFunc="(val, token) => SearchForComp(val, token, ExcludeCompetences(number))"
                                 ToStringFunc="@(c => c == null ? null : $"{c.Name} ({c.Description})")"
                                 Clearable="true" />
            </MudItem>
        }
        <MudItem xs="12" md="12">
            <MudText Class="mb-n3" Typo="Typo.body2">
                Selectie:
                <MudChip T="string">@(comp1?.Name ?? "Niet geselecteerd")</MudChip>
                <MudChip T="string">@(comp2?.Name ?? "Niet geselecteerd")</MudChip>
                <MudChip T="string">@(comp3?.Name ?? "Niet geselecteerd")</MudChip>
            </MudText>
        </MudItem>
    </MudGrid>

    <div class="mt-4">
        <button class="btn btn-outline-secondary me-2" @onclick="() => OnBack.InvokeAsync()">Terug</button>
        <button class="btn btn-success" @onclick="() => OnNext.InvokeAsync()" disabled="@(!CanProceed)">Volgende</button>
    </div>
}

@code {
    [Parameter] public EventCallback OnNext { get; set; }
    [Parameter] public EventCallback OnBack { get; set; }
    [Parameter] public string Mode { get; set; } = "interests"; // "skills" of "interests"

    private Competence comp1, comp2, comp3;
    private List<Competence> AllCompetences { get; set; } = new();

    private bool _disposed;
    private bool _isFirstRender = true;
    private bool IsLoading = true;

    private bool CanProceed => comp1 != null && comp2 != null && comp3 != null
                               && comp1 != comp2 && comp1 != comp3 && comp2 != comp3;

    private string Title => Mode == "skills" ? "Kies 3 vaardigheden die je bezit." : "Kies 3 competenties waarin je interesse hebt.";
    private string Subtitle => "Geen zorgen, later kan je meer kiezen!";

    public void Dispose()
    {
        _disposed = true;
    }

    protected override async Task OnInitializedAsync()
    {
        var competences = await CompetenceRepository.GetAllAsync();
        if (_disposed) return;

        AllCompetences = competences;
        IsLoading = false;
        await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _isFirstRender)
        {
            await StateStorage.LoadAsync();
            var selected = Mode == "skills" ? StateStorage.CurrentState.SelectedSkills : StateStorage.CurrentState.SelectedInterests;
            if (selected != null)
            {
                selected.TryGetValue(1, out comp1);
                selected.TryGetValue(2, out comp2);
                selected.TryGetValue(3, out comp3);
            }

            _isFirstRender = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SelectCompetenceAsync(int number, Competence competence)
    {
        switch (number)
        {
            case 1: comp1 = competence; break;
            case 2: comp2 = competence; break;
            case 3: comp3 = competence; break;
        }

        await SetupService.UpdateCompetenceDictionary(number, competence, Mode);
        await InvokeAsync(StateHasChanged);
    }

    private Competence GetComp(int number) => number switch
    {
        1 => comp1,
        2 => comp2,
        3 => comp3,
        _ => null
    };

    private Competence[] ExcludeCompetences(int number)
    {
        return number switch
        {
            1 => new[] { comp2, comp3 },
            2 => new[] { comp1, comp3 },
            3 => new[] { comp1, comp2 },
            _ => Array.Empty<Competence>()
        };
    }

    private IEnumerable<Competence> GetAvailableCompetences(params Competence[] exclude)
    {
        return AllCompetences.Where(c => !exclude.Contains(c)).ToList();
    }

    private Task<IEnumerable<Competence>> SearchForComp(string value, CancellationToken token, Competence[] exclude)
    {
        return Task.FromResult(FilterCompetences(value, GetAvailableCompetences(exclude)));
    }

    private IEnumerable<Competence> FilterCompetences(string value, IEnumerable<Competence> source)
    {
        if (string.IsNullOrWhiteSpace(value))
            return source;

        return source.Where(c => c.Name.Contains(value, StringComparison.InvariantCultureIgnoreCase)).ToList();
    }
}